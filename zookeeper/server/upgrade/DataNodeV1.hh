// File generated by hadoop record compiler. Do not edit.

#ifndef DataNodeV1_HH_
#define DataNodeV1_HH_

#include "Efc.hh"

#include "../../data/ACL.hh"
#include "../../data/Stat.hh"
#include "../../data/StatPersistedV1.hh"
#include "../../../jute/inc/EIndex.hh"
#include "../../../jute/inc/ERecord.hh"
#include "../../../jute/inc/EBinaryInputArchive.hh"
#include "../../../jute/inc/EBinaryOutputArchive.hh"
#include "../../../jute/inc/ECsvOutputArchive.hh"

namespace efc {
namespace ezk {

/**
 * This class contains the data for a node in the data tree.
 * <p>
 * A data node contains a reference to its parent, a byte array as its data, an
 * array of ACLs, a stat object, and a set of its children's paths.
 * 
 */

class DataNodeV1: public ERecord, public ESynchronizeable {
public:
	sp<DataNodeV1> parent;
    sp<EA<byte> > data;
    sp<EList<sp<ACL> > > acl;
    sp<StatPersistedV1> stat;
    sp<EHashSet<EString*> > children;// = new HashSet<String>();

public:
    DataNodeV1() {
        // default rather than public constructor
    }

    DataNodeV1(sp<DataNodeV1> parent, sp<EA<byte> > data, sp<EList<sp<ACL> > > acl, sp<StatPersistedV1> stat) {
        this->parent = parent;
        this->data = data;
        this->acl = acl;
        this->stat = stat;
        this->children = new EHashSet<EString*>();
    }
    

    /**
     * convenience method for creating DataNode
     * fully
     * @param children
     */
    void setChildren(sp<EHashSet<EString*> > children) {
        this->children = children;
    }
    
    /**
     * convenience methods to get the children
     * @return the children of this datanode
     */
    sp<EHashSet<EString*> > getChildren() {
        return this->children;
    }

    void copyStat(Stat& to) {
        to.setAversion(stat->getAversion());
        to.setCtime(stat->getCtime());
        to.setCversion(stat->getCversion());
        to.setCzxid(stat->getCzxid());
        to.setMtime(stat->getMtime());
        to.setMzxid(stat->getMzxid());
        to.setVersion(stat->getVersion());
        to.setEphemeralOwner(stat->getEphemeralOwner());
        to.setDataLength(data->length());
        to.setNumChildren(children->size());
    }

    virtual void deserialize(EInputArchive* a_, const char* tag) THROWS(EIOException) {
    	a_->startRecord("node");
        data = a_->readBuffer("data");
        sp<EIndex> i = a_->startVector("acl");
        if (i != null) {
        	acl = new EArrayList<sp<ACL> >();
            while (!i->done()) {
            	sp<ACL> a = new ACL();
                a->deserialize(a_, "aclEntry");
                acl->add(a);
                i->incr();
            }
        }
        a_->endVector("acl");
        stat = new StatPersistedV1();
        stat->deserialize(a_, "stat");
        a_->endRecord("node");
    }

    synchronized
    virtual void serialize(EOutputArchive* a_, const char* tag) THROWS(EIOException) {
    	SYNCHRONIZED(this) {
			a_->startRecord(this, "node");
			a_->writeBuffer(data.get(), "data");
			a_->startVector(acl.get(), JUTE_SIZE(acl), "acl");
			if (acl != null) {
				int len1 = acl->size();
				for (int vidx1 = 0; vidx1 < len1; vidx1++) {
					ACL* e1 = dynamic_cast<ACL*>(acl->getAt(vidx1).get());
					e1->serialize(a_, "aclEntry");
				}
			}
			a_->endVector(acl.get(), "acl");
			stat->serialize(a_, "stat");
			a_->endRecord(this, "node");
    	}}
    }
};

} /* namespace ezk */
} /* namespace efc */
#endif /* DataNodeV1_HH_ */
