// File generated by hadoop record compiler. Do not edit.

#ifndef TxnHeader_HH_
#define TxnHeader_HH_

#include "Efc.hh"
#include "../../jute/inc/ERecord.hh"
#include "../../jute/inc/EBinaryInputArchive.hh"
#include "../../jute/inc/EBinaryOutputArchive.hh"
#include "../../jute/inc/ECsvOutputArchive.hh"

namespace efc {
namespace ezk {

class TxnHeader: public ERecord {
public:
	llong clientId;
	int cxid;
	llong zxid;
	llong time;
	int type;

    TxnHeader() : clientId(0), cxid(0), zxid(0), time(0), type(0) {
	}
	TxnHeader(llong clientId, int cxid, llong zxid, llong time, int type) {
		this->clientId = clientId;
		this->cxid = cxid;
		this->zxid = zxid;
		this->time = time;
		this->type = type;
	}
	llong getClientId() {
		return clientId;
	}
	void setClientId(llong m_) {
		clientId = m_;
	}
	int getCxid() {
		return cxid;
	}
	void setCxid(int m_) {
		cxid = m_;
	}
	llong getZxid() {
		return zxid;
	}
	void setZxid(llong m_) {
		zxid = m_;
	}
	llong getTime() {
		return time;
	}
	void setTime(llong m_) {
		time = m_;
	}
	int getType() {
		return type;
	}
	void setType(int m_) {
		type = m_;
	}
	virtual void serialize(EOutputArchive* a_, const char* tag)
			THROWS(EIOException) {
		a_->startRecord(this, tag);
		a_->writeLLong(clientId, "clientId");
		a_->writeInt(cxid, "cxid");
		a_->writeLLong(zxid, "zxid");
		a_->writeLLong(time, "time");
		a_->writeInt(type, "type");
		a_->endRecord(this, tag);
	}
	virtual void deserialize(EInputArchive* a_, const char* tag)
			THROWS(EIOException) {
		a_->startRecord(tag);
		clientId = a_->readLLong("clientId");
		cxid = a_->readInt("cxid");
		zxid = a_->readLLong("zxid");
		time = a_->readLLong("time");
		type = a_->readInt("type");
		a_->endRecord(tag);
	}
	virtual EString toString() {
		try {
			EByteArrayOutputStream s;
			ECsvOutputArchive a_(&s);
			a_.startRecord(this, "");
			a_.writeLLong(clientId, "clientId");
			a_.writeInt(cxid, "cxid");
			a_.writeLLong(zxid, "zxid");
			a_.writeLLong(time, "time");
			a_.writeInt(type, "type");
			s.write('\0');
			return (char*) s.data();
		} catch (EThrowable& ex) {
			ex.printStackTrace();
		}
		return "ERROR";
	}
	void write(EDataOutput* out) THROWS(EIOException) {
		EBinaryOutputArchive archive(out);
		serialize(&archive, "");
	}
	void readFields(EDataInput* in) THROWS(EIOException) {
		EBinaryInputArchive archive(in);
		deserialize(&archive, "");
	}
	virtual int compareTo(EObject* peer_) THROWS(EClassCastException) {
		TxnHeader* peer = dynamic_cast<TxnHeader*>(peer_);
		if (!peer) {
			throw EClassCastException(__FILE__, __LINE__,
					"Comparing different types of records.");
		}
		int ret = 0;
		ret = (clientId == peer->clientId) ?
				0 : ((clientId < peer->clientId) ? -1 : 1);
		if (ret != 0)
			return ret;
		ret = (cxid == peer->cxid) ? 0 : ((cxid < peer->cxid) ? -1 : 1);
		if (ret != 0)
			return ret;
		ret = (zxid == peer->zxid) ? 0 : ((zxid < peer->zxid) ? -1 : 1);
		if (ret != 0)
			return ret;
		ret = (time == peer->time) ? 0 : ((time < peer->time) ? -1 : 1);
		if (ret != 0)
			return ret;
		ret = (type == peer->type) ? 0 : ((type < peer->type) ? -1 : 1);
		if (ret != 0)
			return ret;
		return ret;
	}
	virtual boolean equals(EObject* peer_) {
		TxnHeader* peer = dynamic_cast<TxnHeader*>(peer_);
		if (!peer) {
			return false;
		}
		if (peer_ == this) {
			return true;
		}
		boolean ret = false;
		ret = (clientId == peer->clientId);
		if (!ret)
			return ret;
		ret = (cxid == peer->cxid);
		if (!ret)
			return ret;
		ret = (zxid == peer->zxid);
		if (!ret)
			return ret;
		ret = (time == peer->time);
		if (!ret)
			return ret;
		ret = (type == peer->type);
		if (!ret)
			return ret;
		return ret;
	}
	virtual int hashCode() {
		int result = 17;
		int ret;
		ret = (int) (clientId ^ (((ullong) clientId) >> 32));
		result = 37 * result + ret;
		ret = (int) cxid;
		result = 37 * result + ret;
		ret = (int) (zxid ^ (((ullong) zxid) >> 32));
		result = 37 * result + ret;
		ret = (int) (time ^ (((ullong) time) >> 32));
		result = 37 * result + ret;
		ret = (int) type;
		result = 37 * result + ret;
		return result;
	}
	static EString signature() {
		return "LTxnHeader(lilli)";
	}
};

} /* namespace ezk */
} /* namespace efc */
#endif /* TxnHeader_HH_ */
