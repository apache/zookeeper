// File generated by hadoop record compiler. Do not edit.

#ifndef SetACLTxn_HH_
#define SetACLTxn_HH_

#include "Efc.hh"
#include "../../jute/inc/ERecord.hh"
#include "../../jute/inc/EBinaryInputArchive.hh"
#include "../../jute/inc/EBinaryOutputArchive.hh"
#include "../../jute/inc/ECsvOutputArchive.hh"
#include "../data/ACL.hh"

namespace efc {
namespace ezk {

class SetACLTxn: public ERecord {
public:
	EString path;
	sp<EList<sp<ACL> > > acl;
	int version;

	SetACLTxn() : version(0) {
	}
	SetACLTxn(EString path, sp<EList<sp<ACL> > > acl, int version) {
		this->path = path;
		this->acl = acl;
		this->version = version;
	}
	EString getPath() {
		return path;
	}
	void setPath(EString m_) {
		path = m_;
	}
	sp<EList<sp<ACL> > > getAcl() {
		return acl;
	}
	void setAcl(sp<EList<sp<ACL> > > m_) {
		acl = m_;
	}
	int getVersion() {
		return version;
	}
	void setVersion(int m_) {
		version = m_;
	}
	virtual void serialize(EOutputArchive* a_, const char* tag)
			THROWS(EIOException) {
		a_->startRecord(this, tag);
		a_->writeString(path, "path");
		{
			a_->startVector(acl.get(), JUTE_SIZE(acl), "acl");
			if (acl != null) {
				int len1 = acl->size();
				for (int vidx1 = 0; vidx1 < len1; vidx1++) {
					ACL* e1 = dynamic_cast<ACL*>(acl->getAt(vidx1).get());
					a_->writeRecord(e1, "e1");
				}
			}
			a_->endVector(acl.get(), "acl");
		}
		a_->writeInt(version, "version");
		a_->endRecord(this, tag);
	}
	virtual void deserialize(EInputArchive* a_, const char* tag)
			THROWS(EIOException) {
		a_->startRecord(tag);
		path = a_->readString("path");
		{
			sp<EIndex> vidx1 = a_->startVector("acl");
			if (vidx1 != null) {
				acl = new EArrayList<sp<ACL> >();
				for (; !vidx1->done(); vidx1->incr()) {
					sp<ACL> e1 = new ACL();
					a_->readRecord(e1.get(), "e1");
					acl->add(e1);
				}
			}
			a_->endVector("acl");
		}
		version = a_->readInt("version");
		a_->endRecord(tag);
	}
	virtual EString toString() {
		try {
			EByteArrayOutputStream s;
			ECsvOutputArchive a_(&s);
			a_.startRecord(this, "");
			a_.writeString(path, "path");
			{
				a_.startVector(acl.get(), JUTE_SIZE(acl), "acl");
				if (acl != null) {
					int len1 = acl->size();
					for (int vidx1 = 0; vidx1 < len1; vidx1++) {
						ACL* e1 = dynamic_cast<ACL*>(acl->getAt(vidx1).get());
						a_.writeRecord(e1, "e1");
					}
				}
				a_.endVector(acl.get(), "acl");
			}
			a_.writeInt(version, "version");
			a_.endRecord(this, "");
			s.write('\0');
			return (char*) s.data();
		} catch (EThrowable& ex) {
			ex.printStackTrace();
		}
		return "ERROR";
	}
	void write(EDataOutput* out) THROWS(EIOException) {
		EBinaryOutputArchive archive(out);
		serialize(&archive, "");
	}
	void readFields(EDataInput* in) THROWS(EIOException) {
		EBinaryInputArchive archive(in);
		deserialize(&archive, "");
	}
	virtual int compareTo(EObject* peer_) THROWS(EClassCastException) {
		throw EUnsupportedOperationException(__FILE__, __LINE__,
				"comparing SetACLTxn is unimplemented");
	}
	virtual boolean equals(EObject* peer_) {
		SetACLTxn* peer = dynamic_cast<SetACLTxn*>(peer_);
		if (!peer) {
			return false;
		}
		if (peer_ == this) {
			return true;
		}
		boolean ret = false;
		ret = path.equals(&peer->path);
		if (!ret)
			return ret;
		ret = acl->equals(peer->acl.get());
		if (!ret)
			return ret;
		ret = (version == peer->version);
		if (!ret)
			return ret;
		return ret;
	}
	virtual int hashCode() {
		int result = 17;
		int ret;
		ret = path.hashCode();
		result = 37 * result + ret;
		ret = acl.hashCode();
		result = 37 * result + ret;
		ret = (int) version;
		result = 37 * result + ret;
		return result;
	}
	static EString signature() {
		return "LSetACLTxn(s[LACL(iLId(ss))]i)";
	}
};

} /* namespace ezk */
} /* namespace efc */
#endif /* SetACLTxn_HH_ */
